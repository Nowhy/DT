/**
 * Except the very basic structure generated by Eclipse, the rest of codes is written or modified 
 * by us own(Yu QY/Yuan FENG/Qiwei SUN) based on the knowledge adopted from various materials
 * This Android version UI is developed based on settings of SamSung S4.
 **/
package com.example.test;

import java.util.Hashtable;
import com.example.test.R;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.text.method.ScrollingMovementMethod;
import android.view.Gravity;
import android.graphics.*;
import engine.*;
import android.app.Activity;
import android.view.View;
import android.view.View.OnTouchListener;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.MotionEvent;


public class NewGame extends Activity implements OnTouchListener  {
    private float mStartX;
    private float mStartY;
    private float mEndX;
    private float mEndY;
    private int startX = -1;
    private int startY = -1;
    private int endX = 1;
    private int endY = 0;
    private int lastfromX = 0, lastfromY = 0,lastdestX = 0,lastdestY = 0;
    private ImageButton captured = null;
    private int rShuaiX = 4;
    private int bShuaiX = 4;
    private int rShuaiY = 9;
    private int bShuaiY = 0;
    int clickTime = 0; 

    ImageButton[][] chessBoard = new ImageButton[9][10];
    ImageButton[] redCaptured = new ImageButton[16];
    ImageButton[] blackCaptured = new ImageButton[16];
    ImageButton[] red = new ImageButton[16];
    ImageButton[] black = new ImageButton[16];
    Hashtable pieceTable = new Hashtable();
    TextView tv;
    AIBoard aiboard = new engine.AIBoard();
    Recommender r = new engine.Recommender(this);
    Search s = new engine.Search(this);
    Recommender recommender = new engine.Recommender(this);
    Thread t = new Thread(s);
    private int redCounter = 0;
    private int blackCounter = 0;    
    private int captureCounter = 0;
    private boolean captureUndo = false;
    private int width1 = 0;
    private int height1 = 0;
    private int size = 0;
    private int yPosition = 0;
    private int heightLimited = 0;
    boolean isClick = true;
    static int width = 683;
    static int height = 758;
    Rule rule = new Rule(chessBoard,red,black);
    int[] left = new int[9];
    int[] top = new int[10];
    
    //Handler for message output 
    Handler handler = new Handler(){
    	@Override
    	public void handleMessage(Message msg){
    		String s = String.valueOf(msg.obj);
    		tv.append(s);
    	}
    };

    public Handler getHandler(){
    	return handler;
    }
    
    //All transparent pieces
    int[] capturedTransparent = {R.id.captured1,R.id.captured2,R.id.captured3,R.id.captured4,R.id.captured5,
    		R.id.captured6,R.id.captured7,R.id.captured8,R.id.captured9,R.id.captured10,R.id.captured11,
    		R.id.captured12,R.id.captured13,R.id.captured14,R.id.captured15,R.id.captured16,R.id.captured17,
    		R.id.captured18,R.id.captured19,R.id.captured20,R.id.captured21,R.id.captured22,R.id.captured23,
    		R.id.captured24,R.id.captured25,R.id.captured26,R.id.captured27,R.id.captured29,R.id.captured30,
    		R.id.captured31};

    //Given position in pixel, find the index position
    public int findIndexX(float x){
        return (int)(x-size/2)/size;
    }
    public int findIndexY(float y){
        return (int)(y-260)/size;
    }
    
    //Handles the click event, main loop of the application
    public boolean onTouch(View v, MotionEvent event){
        int ea = event.getAction();
        Log.i("TAG", "Touch:" + ea);
        
        //Check whether the user clicks on undo button or chess pieces
 		switch(v.getId()){ 			
         case R.id.undo_label:
        	 //there is no pieces moved
        	 if(startX < 0){
					Toast toast = Toast.makeText(NewGame.this,"No piece to undo", Toast.LENGTH_SHORT);
				    toast.setGravity(Gravity.TOP, 0, 680);
				    toast.show();
        	 }
        	 else{
	        	 if(isClick){
		     		clickTime = clickTime-4;
	        		 if(captureUndo){
	        			 //it is a capture undo case
	        			 undo(true);
	        		 }
	        		 else{
	        			 //it is a move undo case
	        			 undo(false);
	        			 
	        		 }
	        		 //stop current search thread and update the aiboard
	    			 s.keepSearching = false;
	    			 AIBoard.undo();
	    			 //start to run engine thread again
	    			 s.keepSearching = true;
	    			 r.getRecords();
	    			 t.run();	
	    			 try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
		     		isClick = false;
	        	 }
        	 }
        	 break;
        //while user clicks the chess pieces
         default:
        	 switch (ea) {
        	 case MotionEvent.ACTION_DOWN:
        		 clickTime++;
        		 //user clicks to choose the first location
        		 if(clickTime%4 == 1){
        			 	//get the logical index of the current chess piece
						mStartX = (int) event.getRawX();// get X
						mStartY = (int) event.getRawY();//get Y
						startX = findIndexX(mStartX);
						startY = findIndexY(mStartY);
						//if there is no chess piece exist in the position that the user chooses
						if(!rule.isChessExist(startX, startY)){
							clickTime--;
						}
						//chess piece exists and it is black turn
						else if(Math.abs(clickTime)%8 == 0 || Math.abs(clickTime)%8 == 7 || Math.abs(clickTime)%8 == 6 || Math.abs(clickTime)%8 == 5){
							//disable all red ones
							for(int i = 0;i<red.length;i++){
								red[i].setEnabled(false);
							}
							//enable all existing black ones
						    for(int m = 0; m<black.length;m++){
						        int existCounter = 0;
						        for(int n = 0; n<blackCaptured.length;n++){
						            if(black[m].equals(blackCaptured[n])){
						                existCounter++;
						            }
						        }
						        if(existCounter == blackCaptured.length){
						            black[m].setEnabled(true);
						        }
						    }
						}
						//chess piece exists and it is red turn
						else{
							//disable all black ones
							for(int i = 0;i<black.length;i++){
							    black[i].setEnabled(false);
							}
							//enable all existing red ones
						    for(int m = 0; m<red.length;m++){
						        int existCounter = 0;
						        for(int n = 0; n<redCaptured.length;n++){
						            if(red[m].equals(redCaptured[n])){
						                existCounter++;
						            }
						        }
						            if(existCounter == redCaptured.length){
						                red[m].setEnabled(true);
						            }
						    }
						}
	            }
				if(clickTime%4 == 3){
				//do nothing
				}
				break;
				
				case MotionEvent.ACTION_UP:
	            clickTime++;
				if(clickTime%4 == 1){
				      if(!rule.isChessExist(startX, startY)){
				      	   clickTime--;
				      }
				}
				//user clicks the first position 
	            else if(clickTime%4 == 2){
	            	//highlight when clicks
	            	chessBoard[startX][startY].getBackground().setColorFilter(0x77000000, PorterDuff.Mode.SRC_ATOP);
	            	chessBoard[startX][startY].setBackgroundResource(R.drawable.pic); 
	            	//when it is black turn
	            	if(Math.abs(clickTime)%8 == 0 || Math.abs(clickTime)%8 == 7 || Math.abs(clickTime)%8 == 6 || Math.abs(clickTime)%8 == 5){
						//enable all red ones
						for(int i = 0;i<red.length;i++){
						    red[i].setEnabled(true);
						}
					}
					else{
						//enable all black ones
						for(int i = 0;i<black.length;i++){
							black[i].setEnabled(true);
						}
					}
	            }
				//user clicks the second position
	            else if(clickTime%4 == 0){
	            	//highlight
	            	chessBoard[startX][startY].getBackground().setColorFilter(0x77000000, PorterDuff.Mode.SRC_ATOP);
	            	chessBoard[startX][startY].setBackgroundResource(R.drawable.transparent);
	            	//find the index that the second position user clicks
					mEndX = (int) event.getRawX();
					mEndY = (int) event.getRawY();
					endX = findIndexX(mEndX);
					endY = findIndexY(mEndY);
					//if the second position is invalid
					if(!rule.isSecondValid(startX, startY, endX, endY, clickTime,red, black)){
						//
						Toast toast = Toast.makeText(NewGame.this,"Invalid second selection \n           Select again", Toast.LENGTH_SHORT);
					    toast.setGravity(Gravity.TOP, 0, 680);
					    toast.show();
						clickTime=clickTime-4;
					}
					//second position is valid
					else{
						s.keepSearching=false;
						try {
							Thread.sleep(50);
						} catch (InterruptedException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}
						//Generals can not face Generals
						if( r.kingFace(startY*9+startX, endY*9+endX)||r.getCheck(startY*9+startX, endY*9+endX)){
							if(r.kingFace(startY*9+startX, endY*9+endX)){
								Toast toast = Toast.makeText(NewGame.this,"Generals cannot be faced.  \n           Select again", Toast.LENGTH_SHORT);
							    toast.setGravity(Gravity.TOP, 0, 680);
							    toast.show();
							}
							else{
								Toast toast = Toast.makeText(NewGame.this,"Your general is being captured.  \n             Select again", Toast.LENGTH_SHORT);
							    toast.setGravity(Gravity.TOP, 0, 680);
							    toast.show();
							}
							clickTime=clickTime-4;
						}
						//When Generals are not faced
						else{
							//if the second position is empty
							if(!rule.isChessExist(endX, endY)){
								captureUndo = false;
							    move((endX-startX),(endY-startY),startX,startY);
							    captured = null;
						        AIBoard.update(startY*9+startX,endY*9+endX);
						        s.keepSearching = true;
						        r.getRecords();
						        t.run();
							    isClick = true;
							    try {
									Thread.sleep(100);
								} catch (InterruptedException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
							 }
							//the second position is not empty
							else{
								boolean isCaptured = false;
								if(rule.isWin(chessBoard[endX][endY])){
								    isCaptured = true;
								}
								//when it is black turn
								if(Math.abs(clickTime)%8 == 0 || Math.abs(clickTime)%8 == 7 || Math.abs(clickTime)%8 == 6 || Math.abs(clickTime)%8 == 5){
									redCaptured[redCounter] = chessBoard[endX][endY];
									redCounter++;
									//
									if(isCaptured){
									    Toast toast = Toast.makeText(NewGame.this,"Red lose.", Toast.LENGTH_SHORT);
									    toast.setGravity(Gravity.TOP, 0, 680);
									    toast.show();
										for(int i = 0;i<red.length;i++){
											red[i].setEnabled(false);
										}
										for(int i = 0;i<black.length;i++){
											black[i].setEnabled(false);
										}
									}
								}
								//when it is red turn
								else{
									 blackCaptured[blackCounter] = chessBoard[endX][endY];
									 blackCounter++;
									 if(isCaptured){
										    Toast toast = Toast.makeText(NewGame.this,"Black lose.", Toast.LENGTH_SHORT);
										    toast.setGravity(Gravity.TOP, 0, 680);
										    toast.show();
											for(int i = 0;i<red.length;i++){
												red[i].setEnabled(false);
											}
											for(int i = 0;i<black.length;i++){
												black[i].setEnabled(false);
											}
									 }
								 }
								//perform the capture action
								 beingCaptured((endX-startX),(endY-startY),endX,endY,chessBoard);
								 captured = chessBoard[endX][endY];
								 isClick = true;
								 captureUndo = true;
							     //s.keepSearching = false;
							     AIBoard.update(startY*9+startX,endY*9+endX);
							     s.keepSearching = true;
							     r.getRecords();
							     t.run();
						        try{
						        	Thread.sleep(100);
						        }catch(InterruptedException e){
						        	e.printStackTrace();
						        }
								}
								//record the position
								lastfromX = startX;
								lastfromY = startY;
								lastdestX = endX;
								lastdestY = endY;
								//when it is black turn
								if(Math.abs(clickTime)%8 == 0 || Math.abs(clickTime)%8 == 7 || Math.abs(clickTime)%8 == 6 || Math.abs(clickTime)%8 == 5){	
								     for(int j=0;j<black.length;j++){
								         black[j].setEnabled(false);
								     }
								  }
								else{		
								     for(int j=0;j<red.length;j++){
								         red[j].setEnabled(false);
								     }
								}
								//check whether the game ends or not
								if(s.getEndGame()){
									if(Math.abs(clickTime)%8 == 0 || Math.abs(clickTime)%8 == 7 || Math.abs(clickTime)%8 == 6 || Math.abs(clickTime)%8 == 5){//when it is black
										Toast toast = Toast.makeText(NewGame.this,"Black lose.", Toast.LENGTH_SHORT);
									    toast.setGravity(Gravity.TOP, 0, 680);
									    toast.show();
									}
									else{//it is red
										Toast toast = Toast.makeText(NewGame.this,"Red lose.", Toast.LENGTH_SHORT);
									    toast.setGravity(Gravity.TOP, 0, 680);
									    toast.show();
									}
									for(int i = 0;i<red.length;i++){
										red[i].setEnabled(false);
									}
									for(int i = 0;i<black.length;i++){
										black[i].setEnabled(false);
									}
								}
								
						}
					}
	            }
	            break;
        	 	}
	         break;
	         }
 		return false;
    }
    //initialize the whole new game playing page
    //create chessboard/chess pieces/all needed objects at the beginning
    protected void onCreate(Bundle savedInstanceState){
        DisplayMetrics metric = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(metric);
        width1 = metric.widthPixels;
        height1 = metric.heightPixels;
        size = (int) (width1/9.8);

        left[0] = size/2;
        left[1] = 3*size/2;
        left[2] = 5*size/2;
        left[3] = 7*size/2;
        left[4] = 9*size/2;
        left[5] = 11*size/2;
        left[6] = 13*size/2;
        left[7] = 15*size/2;
        left[8] = 17*size/2;
        top[0] = size/2;
        top[1] = 3*size/2;
        top[2] = 5*size/2;
        top[3] = 7*size/2;
        top[4] = 9*size/2;
        top[5] = 11*size/2;
        top[6] = 13*size/2;
        top[7] = 15*size/2;
        top[8] = 17*size/2;
        top[9] = 19*size/2;
        
        System.out.println("abc");
        super.onCreate(savedInstanceState);
        setContentView(R.layout.newgame);
        
        Button undo = (Button) findViewById(R.id.undo_label);
        undo.setOnTouchListener(this);        
        
        tv = (TextView) findViewById(R.id.recommend_title);
        
        heightLimited = 2*top[9] - top[8];
        
        //initialize the 2D array of chess board
        chessBoard[0][0] = initialization(R.id.bju1,0,0);
        chessBoard[1][0] = initialization(R.id.bma1,1,0);
        chessBoard[2][0] = initialization(R.id.bxiang1,2,0);
        chessBoard[3][0] = initialization(R.id.bshi1,3,0);
        chessBoard[4][0] = initialization(R.id.bshuai,4,0);
        chessBoard[5][0] = initialization(R.id.bshi2,5,0);
        chessBoard[6][0] = initialization(R.id.bxiang2,6,0);
        chessBoard[7][0] = initialization(R.id.bma2,7,0);
        chessBoard[8][0] = initialization(R.id.bju2,8,0);

        chessBoard[0][1] = initialization(R.id.transparent1,0,1);
        chessBoard[1][1] = initialization(R.id.transparent2,1,1);
        chessBoard[2][1] = initialization(R.id.transparent3,2,1);
        chessBoard[3][1] = initialization(R.id.transparent4,3,1);
        chessBoard[4][1] = initialization(R.id.transparent5,4,1);
        chessBoard[5][1] = initialization(R.id.transparent6,5,1);
        chessBoard[6][1] = initialization(R.id.transparent7,6,1);
        chessBoard[7][1] = initialization(R.id.transparent8,7,1);
        chessBoard[8][1] = initialization(R.id.transparent9,8,1);

        chessBoard[0][2] = initialization(R.id.transparent10,0,2);
        chessBoard[1][2] = initialization(R.id.bpao1,1,2);
        chessBoard[2][2] = initialization(R.id.transparent11,2,2);
        chessBoard[3][2] = initialization(R.id.transparent12,3,2);
        chessBoard[4][2] = initialization(R.id.transparent13,4,2);
        chessBoard[5][2] = initialization(R.id.transparent14,5,2);
        chessBoard[6][2] = initialization(R.id.transparent15,6,2);
        chessBoard[7][2] = initialization(R.id.bpao2,7,2);
        chessBoard[8][2] = initialization(R.id.transparent16,8,2);

        chessBoard[0][3] = initialization(R.id.bbing1,0,3);
        chessBoard[1][3] = initialization(R.id.transparent17,1,3);
        chessBoard[2][3] = initialization(R.id.bbing2,2,3);
        chessBoard[3][3] = initialization(R.id.transparent18,3,3);
        chessBoard[4][3] = initialization(R.id.bbing3,4,3);
        chessBoard[5][3] = initialization(R.id.transparent19,5,3);
        chessBoard[6][3] = initialization(R.id.bbing4,6,3);
        chessBoard[7][3] = initialization(R.id.transparent20,7,3);
        chessBoard[8][3] = initialization(R.id.bbing5,8,3);

        chessBoard[0][4] = initialization(R.id.transparent21,0,4);
        chessBoard[1][4] = initialization(R.id.transparent22,1,4);
        chessBoard[2][4] = initialization(R.id.transparent23,2,4);
        chessBoard[3][4] = initialization(R.id.transparent24,3,4);
        chessBoard[4][4] = initialization(R.id.transparent25,4,4);
        chessBoard[5][4] = initialization(R.id.transparent26,5,4);
        chessBoard[6][4] = initialization(R.id.transparent27,6,4);
        chessBoard[7][4] = initialization(R.id.transparent28,7,4);
        chessBoard[8][4] = initialization(R.id.transparent29,8,4);

        chessBoard[0][5] = initialization(R.id.transparent30,0,5);
        chessBoard[1][5] = initialization(R.id.transparent31,1,5);
        chessBoard[2][5] = initialization(R.id.transparent32,2,5);
        chessBoard[3][5] = initialization(R.id.transparent33,3,5);
        chessBoard[4][5] = initialization(R.id.transparent34,4,5);
        chessBoard[5][5] = initialization(R.id.transparent35,5,5);
        chessBoard[6][5] = initialization(R.id.transparent36,6,5);
        chessBoard[7][5] = initialization(R.id.transparent37,7,5);
        chessBoard[8][5] = initialization(R.id.transparent38,8,5);

        chessBoard[0][6] = initialization(R.id.rbing1,0,6);
        chessBoard[1][6] = initialization(R.id.transparent39,1,6);
        chessBoard[2][6] = initialization(R.id.rbing2,2,6);
        chessBoard[3][6] = initialization(R.id.transparent40,3,6);
        chessBoard[4][6] = initialization(R.id.rbing3,4,6);
        chessBoard[5][6] = initialization(R.id.transparent41,5,6);
        chessBoard[6][6] = initialization(R.id.rbing4,6,6);
        chessBoard[7][6] = initialization(R.id.transparent42,7,6);
        chessBoard[8][6] = initialization(R.id.rbing5,8,6);

        chessBoard[0][7] = initialization(R.id.transparent43,0,7);
        chessBoard[1][7] = initialization(R.id.rpao1,1,7);
        chessBoard[2][7] = initialization(R.id.transparent44,2,7);
        chessBoard[3][7] = initialization(R.id.transparent45,3,7);
        chessBoard[4][7] = initialization(R.id.transparent46,4,7);
        chessBoard[5][7] = initialization(R.id.transparent47,5,7);
        chessBoard[6][7] = initialization(R.id.transparent48,6,7);
        chessBoard[7][7] = initialization(R.id.rpao2,7,7);
        chessBoard[8][7] = initialization(R.id.transparent49,8,7);

        chessBoard[0][8] = initialization(R.id.transparent50,0,8);
        chessBoard[1][8] = initialization(R.id.transparent51,1,8);
        chessBoard[2][8] = initialization(R.id.transparent52,2,8);
        chessBoard[3][8] = initialization(R.id.transparent53,3,8);
        chessBoard[4][8] = initialization(R.id.transparent54,4,8);
        chessBoard[5][8] = initialization(R.id.transparent55,5,8);
        chessBoard[6][8] = initialization(R.id.transparent56,6,8);
        chessBoard[7][8] = initialization(R.id.transparent57,7,8);
        chessBoard[8][8] = initialization(R.id.transparent58,8,8);

        chessBoard[0][9] = initialization(R.id.rju1,0,9);
        chessBoard[1][9] = initialization(R.id.rma1,1,9);
        chessBoard[2][9] = initialization(R.id.rxiang1,2,9);
        chessBoard[3][9] = initialization(R.id.rshi1,3,9);
        chessBoard[4][9] = initialization(R.id.rshuai,4,9);
        chessBoard[5][9] = initialization(R.id.rshi2,5,9);
        chessBoard[6][9] = initialization(R.id.rxiang2,6,9);
        chessBoard[7][9] = initialization(R.id.rma2,7,9);
        chessBoard[8][9] = initialization(R.id.rju2,8,9);
        
        black[0] = initialization(R.id.bju1,0,0);
        black[1] = initialization(R.id.bma1,1,0);
        black[2] = initialization(R.id.bxiang1,2,0);
        black[3] = initialization(R.id.bshi1,3,0);
        black[4] = initialization(R.id.bshuai,4,0);
        black[5] = initialization(R.id.bshi2,5,0);
        black[6] = initialization(R.id.bxiang2,6,0);
        black[7] = initialization(R.id.bma2,7,0);
        black[8] = initialization(R.id.bju2,8,0);
        black[9] = initialization(R.id.bpao1,1,2);
        black[10] = initialization(R.id.bpao2,7,2);
        black[11] = initialization(R.id.bbing1,0,3);
        black[12] = initialization(R.id.bbing2,2,3);
        black[13] = initialization(R.id.bbing3,4,3);
        black[14] = initialization(R.id.bbing4,6,3);
        black[15] = initialization(R.id.bbing5,8,3);

        for(int i=0;i<15;i++){
        	black[i].setEnabled(false);
        }

        red[0] = initialization(R.id.rju1,0,9);
        red[1] = initialization(R.id.rma1,1,9);
        red[2] = initialization(R.id.rxiang1,2,9);
        red[3] = initialization(R.id.rshi1,3,9);
        red[4] = initialization(R.id.rshuai,4,9);
        red[5] = initialization(R.id.rshi2,5,9);
        red[6] = initialization(R.id.rxiang2,6,9);
        red[7] = initialization(R.id.rma2,7,9);
        red[8] = initialization(R.id.rju2,8,9);
        red[9] = initialization(R.id.rpao1,1,7);
        red[10] = initialization(R.id.rpao2,7,7);
        red[11] = initialization(R.id.rbing1,0,6);
        red[12] = initialization(R.id.rbing2,2,6);
        red[13] = initialization(R.id.rbing3,4,6);
        red[14] = initialization(R.id.rbing4,6,6);
        red[15] = initialization(R.id.rbing5,8,6);

        pieceTable.put(R.id.bju1, "Black 車");
        pieceTable.put(R.id.bma1, "Black 馬");
        pieceTable.put(R.id.bxiang1, "Black 象");
        pieceTable.put(R.id.bshi1, "Black 士");
        pieceTable.put(R.id.bshuai, "Black 將");
        pieceTable.put(R.id.bshi2, "Black 士");
        pieceTable.put(R.id.bxiang2, "Black 象");
        pieceTable.put(R.id.bma2, "Black 馬");
        pieceTable.put(R.id.bju2, "Black 車");

        pieceTable.put(R.id.bpao1, "Black 炮");
        pieceTable.put(R.id.bpao2, "Black 炮");

        pieceTable.put(R.id.bbing1, "Black 卒");
        pieceTable.put(R.id.bbing2, "Black 卒");
        pieceTable.put(R.id.bbing3, "Black 卒");
        pieceTable.put(R.id.bbing4, "Black 卒");
        pieceTable.put(R.id.bbing5, "Black 卒");

        pieceTable.put(R.id.rju1, "Red 車");
        pieceTable.put(R.id.rma1, "Red 馬");
        pieceTable.put(R.id.rxiang1, "Red 相");
        pieceTable.put(R.id.rshi1, "Red 仕");
        pieceTable.put(R.id.rshuai, "Red 帥");
        pieceTable.put(R.id.rshi2, "Red 仕");
        pieceTable.put(R.id.rxiang2, "Red 相");
        pieceTable.put(R.id.rma2, "Red 馬");
        pieceTable.put(R.id.rju2, "Red 車");

        pieceTable.put(R.id.rpao1, "Red 炮");
        pieceTable.put(R.id.rpao2, "Red 炮");

        pieceTable.put(R.id.rbing1, "Red 兵");
        pieceTable.put(R.id.rbing2, "Red 兵");
        pieceTable.put(R.id.rbing3, "Red 兵");
        pieceTable.put(R.id.rbing4, "Red 兵");
        pieceTable.put(R.id.rbing5, "Red 兵");

		r.getRecords();
        t.start();
        try{
        	Thread.sleep(100);
        }catch(InterruptedException e){
        	e.printStackTrace();
        }
        //make the textview field able to be scrolled
        tv.setMovementMethod(ScrollingMovementMethod.getInstance());

}
    //move action execution
    public void move(int deltaX, int deltaY, int x, int y){
        ImageButton btnS = chessBoard[x][y];
        ImageButton btnE = chessBoard[x+deltaX][y+deltaY];
        chessBoard[x+deltaX][y+deltaY] = btnS;
        chessBoard[x][y] = btnE;
        RelativeLayout.LayoutParams pBtnS = (RelativeLayout.LayoutParams) chessBoard[x+deltaX][y+deltaY].getLayoutParams();
        pBtnS.setMargins(left[x+deltaX], top[y+deltaY], width - left[x+deltaX], height - top[y+deltaY]);
        RelativeLayout.LayoutParams pBtnE = (RelativeLayout.LayoutParams) chessBoard[x][y].getLayoutParams();
        pBtnE.setMargins(left[x], top[y], width - left[x], height - top[y]);
        chessBoard[x][y].requestLayout();
    }
    
    //capture action execution
	public void beingCaptured(int deltaX, int deltaY, int x, int y, ImageButton[][] chessBoard){
		//disable the being captured one
		chessBoard[x][y].setEnabled(false);
	    chessBoard[x][y].setVisibility(View.INVISIBLE);
		//set a transparent piece on it
	    chessBoard[x][y] = initialization(capturedTransparent[captureCounter],x,y);
        move(deltaX,deltaY,x-deltaX,y-deltaY);
        captureCounter++;
	}

	//output suggestion to the textview field
	public void suggestion(CharSequence c){
		tv.append(c);
	}
    
	//undo action execution
    public void undo(boolean isCapture){
    	//when it is a capture action
    	if(isCapture){
            if((Math.abs(clickTime)+4)%8 == 0 || (Math.abs(clickTime)+4)%8 == 7 || (Math.abs(clickTime)+4)%8 == 6 || (Math.abs(clickTime)+4)%8 == 5){
            	//when it is black
            	redCounter--;
            	ImageButton temp1 = redCaptured[redCounter];
            	ImageButton temp2 = chessBoard[lastdestX][lastdestY];

            	chessBoard[lastfromX][lastfromY] = temp2;
            	chessBoard[lastdestX][lastdestY] = temp1;
            	
                RelativeLayout.LayoutParams pBtn1 = (RelativeLayout.LayoutParams) temp1.getLayoutParams();
                pBtn1.setMargins(left[lastdestX], top[lastdestY], width - left[lastdestX], height - top[lastdestY]);
                chessBoard[lastdestX][lastdestY].setEnabled(true);
                chessBoard[lastdestX][lastdestY].setVisibility(View.VISIBLE);

                RelativeLayout.LayoutParams pBtn2 = (RelativeLayout.LayoutParams) temp2.getLayoutParams();
                pBtn2.setMargins(left[lastfromX], top[lastfromY], width - left[lastfromX], height - top[lastfromY]);
                chessBoard[lastfromX][lastfromY].setOnTouchListener(this);
            	chessBoard[lastfromX][lastfromY].requestLayout();
                }
            else{
            	//when it is red
            	blackCounter--;
            	ImageButton temp1 = blackCaptured[blackCounter];
            	ImageButton temp2 = chessBoard[lastdestX][lastdestY];

            	chessBoard[lastfromX][lastfromY] = temp2;
            	chessBoard[lastdestX][lastdestY] = temp1;
            	
                RelativeLayout.LayoutParams pBtn1 = (RelativeLayout.LayoutParams) temp1.getLayoutParams();
                pBtn1.setMargins(left[lastdestX], top[lastdestY], width - left[lastdestX], height - top[lastdestY]);
                chessBoard[lastdestX][lastdestY].setEnabled(true);
                chessBoard[lastdestX][lastdestY].setVisibility(View.VISIBLE);

                RelativeLayout.LayoutParams pBtn2 = (RelativeLayout.LayoutParams) temp2.getLayoutParams();
                pBtn2.setMargins(left[lastfromX], top[lastfromY], width - left[lastfromX], height - top[lastfromY]);
                chessBoard[lastfromX][lastfromY].setOnTouchListener(this);
            	chessBoard[lastfromX][lastfromY].requestLayout();
            }
            captureCounter--;
    		captureUndo = false;
    		
    	}
    	//when it is a move action
    	else{
    		move((lastfromX-lastdestX),(lastfromY-lastdestY),lastdestX,lastdestY);
    	}
        if(Math.abs(clickTime)%8 == 0 || Math.abs(clickTime)%8 == 7 || Math.abs(clickTime)%8 == 6 || Math.abs(clickTime)%8 == 5){//when it is black
            //enable all red ones
            for(int i = 0;i<red.length;i++){
                red[i].setEnabled(true);
            }
         }
        else{
        	//enable all black ones
          	 for(int i = 0;i<black.length;i++){
                black[i].setEnabled(true);
          	 }
        }
    }

    //initialization of all chess pieces
    public ImageButton initialization(int id, int x, int y){
        ImageButton btn = (ImageButton) findViewById(id);
        RelativeLayout.LayoutParams pBtn = (RelativeLayout.LayoutParams) btn.getLayoutParams();
        pBtn.setMargins(left[x], top[y], width - left[x], height - top[y]);
        btn.setOnTouchListener(this);
        return btn;
    }
    
    //getters
    public Hashtable getPieceTable(){
    	return pieceTable;
    }
    
    public ImageButton[][] getChessBoard(){
    	return chessBoard;
    }
    
    //output warning string of black turn
    public void reminderBlack(String b){
    	Toast toast = Toast.makeText(NewGame.this,"Warning: \n"+ b,
    			Toast.LENGTH_SHORT);
    	toast.setGravity(Gravity.TOP, 0, 0);
    	toast.show();
    }
    
    //output warning string of red turn
    public void reminderRed(String r){
    	Toast toast = Toast.makeText(NewGame.this, "Warning: \n"+r,
    			Toast.LENGTH_SHORT);
    	toast.setGravity(Gravity.TOP, 0, 0);
    	toast.show();
    }
}